Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3
Note:
Bonus points if you could solve it both recursively and iteratively.

Subscribe to see which companies asked this question

================codes==================
package leetcode;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

public class Solution1 {
	
	ArrayList<Integer> al1 = new ArrayList<Integer>();
	ArrayList<Integer> al2 = new ArrayList<Integer>();  
	public boolean isSymmetric(TreeNode root) {
        boolean flag = false;
        if(root == null ||(root.left == null && root.right == null)) return true;
        if(root.left != null && root.right != null){
        	preorder(root.left);
	        preorder2(root.right);
	        for(int num : al1){
	        	System.out.println(num + ",");
	        }
	        if(al1.size() != al2.size()) return false;
	        for(int i = 0 ;i < al1.size(); i++){
	        	if(al1.get(i)!=al2.get(i)){
	        		return flag;
	        	}
	        }
	        flag = true;
	        return flag;
        }
        else return false;
        
    }
	
	 protected void preorder(TreeNode p) { 
		 
		 if (p != null) { 
	     	al1.add(p.val);
	     	preorder(p.left);  
	        preorder(p.right);  
	     }
	 }  
	  
	 protected void preorder2(TreeNode p) {  
		  
		 if (p != null) {  
			 if(p.left == null && p.right ==null)
	            al2.add(p.val);  
	            preorder(p.right);  
	            preorder(p.left);  
	     }
	 }
	public static void main(String[] args){
		Solution1 s1 = new Solution1();
		TreeNode n0 = new TreeNode(1);
		TreeNode n1 = new TreeNode(2);
		TreeNode n2 = new TreeNode(2);
		TreeNode n3 = new TreeNode(3);
		TreeNode n4 = new TreeNode(0);
		TreeNode n5 = new TreeNode(3);
		TreeNode n6 = new TreeNode(0);
		TreeNode n7 = new TreeNode(8);
		TreeNode n8 = new TreeNode(9);
		TreeNode n9 = new TreeNode(10);
		
		n0.left = n1; n0.right = n2;
		n1.left = n3; n1.right = n4; n2.left = n5; n2.right = n6;
		boolean res = s1.isSymmetric(n0);
		System.out.println(res);
	}
}

class ListNode {
	      int val;
	      ListNode next;
	      ListNode(int x) { val = x; }
	  }

class TreeNode {
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode(int x) { val = x; }
}
